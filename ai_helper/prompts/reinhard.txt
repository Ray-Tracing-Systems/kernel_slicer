Here is an example of Reinhard tone mapping implementation in kernel_slicer:

#include "LiteMath.h"

using LiteMath::float2;
using LiteMath::float3;
using LiteMath::float4; 

class ReinhardTM
{
public:
  ReinhardTM(){}
  
  virtual void Run(int w, int h, const float* inData [[size("w*h*4")]], uint32_t* outData [[size("w*h")]]);

  virtual void CommitDeviceData(){}
  virtual void GetExecutionTime(const char* a_funcName, float a_out[4]){ a_out[0] = m_time;}

  float getWhitePoint() const { return whitePoint; }

protected:

  virtual void kernel1D_finMax(const float* inData, int size);
  virtual void kernel2D_process(int w, int h, const float* inData, uint32_t* outData);

  float whitePoint;
  float m_time;
};

float reinhard_extended(float v, float max_white)
{
  float numerator = v * (1.0f + (v / (max_white * max_white)));
  return numerator / (1.0f + v);
}

void ReinhardTM::kernel1D_finMax(const float* hdrData, int size)
{
  whitePoint = 0.0;
  for(int i=0;i<size;i++)
  {
    float r = hdrData[4*i+0];
    float g = hdrData[4*i+1];
    float b = hdrData[4*i+2];
    float maxValue = std::max(r, std::max(g,b));
    whitePoint = std::max(whitePoint, maxValue);
  }  

}

void ReinhardTM::kernel2D_process(int w, int h, const float* hdrData, uint32_t* ldrData)
{
  for(int y=0;y<h;y++)
  {
    for(int x=0;x<w;x++)
    {
      float r = reinhard_extended(hdrData[4*(y*w+x)+0], whitePoint);
      float g = reinhard_extended(hdrData[4*(y*w+x)+1], whitePoint);
      float b = reinhard_extended(hdrData[4*(y*w+x)+2], whitePoint);
      
      int ir  = (int)std::min(r*255.0f, 255.0f);
      int ig  = (int)std::min(g*255.0f, 255.0f);
      int ib  = (int)std::min(b*255.0f, 255.0f);
      
      ldrData[y*w+x] = 0xFF000000 | (ib << 16) | (ig << 8) | ir;
    }
  }
}

void ReinhardTM::Run(int w, int h, const float* hdrData, uint32_t* ldrData)
{
  auto before = std::chrono::high_resolution_clock::now();
  kernel1D_finMax(hdrData, w*h);
  kernel2D_process(w,h,hdrData,ldrData);
  m_time = std::chrono::duration_cast<std::chrono::microseconds>(std::chrono::high_resolution_clock::now() - before).count()/1000.f;
}

It has two kernels (kernel1D_finMax and kernel2D_process). 
It has single control function Run where "inData" pointer is input pointer with array size of w*h*4 and oputput outData pointer
kernel1D_finMax has 1D parallel loop indexed by "i".
kernel2D_process has two nested parallel loops indexed by "y" and "x".

Here an example of using this class with the generated by kernel_slicer code:

  std::shared_ptr<ReinhardTM> pImpl = nullptr;
  if(onGPU)
  {
    auto ctx   = vk_utils::globalContextGet(false, 0);
    pImpl = CreateReinhardTM_Generated(ctx, w*h);
  }
  else
    pImpl = std::make_shared<ReinhardTM>();

  pImpl->CommitDeviceData();
  pImpl->Run(w, h, hdrData.data(), ldrData.data()); // (const float4*)

  if(onGPU)
    LiteImage::SaveBMP("zout_gpu.bmp", ldrData.data(), w, h);
  else
    LiteImage::SaveBMP("zout_cpu.bmp", ldrData.data(), w, h);

  std::cout << "whitePoint = " << pImpl->getWhitePoint() << std::endl;

